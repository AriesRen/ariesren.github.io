---
title: 算法-排序优化
date: 2018-11-09 14:30:30
tags: ['算法','排序','排序优化']
categories: 算法
mathjax: true
---

<div style="text-align: center;">
{% note success %} 
### 前言
{% endnote %}
</div>

几乎所有的编程语言中都会提供排序函数，比如C语言中qsort()，C++ STL中的sort()、stable_sort()，还有java中Collections.sort()。在平时开发中，我们都是直接使用这些现成的函数来实现业务逻辑中的排序功能。那你知道这些排序函数是如何实现的吗？底层都利用了那些排序算法？

基于这些问题，今天我们就来看看排序这部分的最后一块内容:**如何实现一个通用的、高性能的排序算法？**

<div style="text-align: center;">
{% note success %} 
### 如何选择合适的排序算法？
{% endnote %}
</div>

如果要实现一个通用的、高效率的排序函数，我们应该选择哪种排序算法？我们先回顾一下前面讲过的几种排序算法。

| 排序算法 | 时间复杂度  | 是否稳定排序？ | 是否原地排序？|
|---------|-------------|---------------|--------------|
| 冒泡排序 | $O(n^2)$    | √             | √            |
| 插入排序 | $O(n^2)$    | √             | √            |
| 选择排序 | $O(n^2)$    | ×             | √            |
| 归并排序 | $O(n*logn)$ | √             | ×            |
| 快速排序 | $O(n*logn)$ | ×             | √            |
| 桶排序   | $O(n)$      | √             | ×            |
| 计数排序 | $O(n+k)$    | √             | ×            |
| 基数排序 | $O(dn)$     | √             | ×            |


我们前面讲过，线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用排序函数，不能选择线性排序算法。

如果对小规模数据进行排序，可以选择时间复杂度为$O(n^2)$的排序算法，如果对大规模数据进行排序，时间复杂度是$O(n\*logn)$的的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度为$O(n\*logn)$的算法来实现排序函数。

时间复杂度为$O(n\*logn)$的函数不止一个，我们已经讲过的有归并排序、快速排序。后面讲堆的时候我们还会讲堆排序。堆排序和快速排序都有比较多的应用，比如java语言采用堆排序实现排序函数，C语言使用排序排序实现排序函数。

不知道你有没有发现，使用归并排序的情况其实并不多。我们知道，快速排序最坏情况下时间复杂度是$O(n^2)$。而归并排序可以做到平均情况、最坏情况的时间复杂度都是$O(n\*logn)$，从这点看起来很诱人，那为什么它还是没能得到“宠幸”呢？

还记得我们上一节将的归并排序的空间复杂度吗？归并排序并不是原地排序算法，空间复杂度是$O(n)$，所以，粗略的将，如果要排序100MB的数据，除了数据本身占用的内存之外，排序算法还要额外在占用100MB的内存空间，空间消耗就翻倍了。



<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 信息流广告 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4127326375481893"
     data-ad-slot="9105526840"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>