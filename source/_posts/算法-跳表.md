---
title: 算法-跳表
date: 2018-12-17 23:33:39
tags: ['算法','跳表']
categories: 算法
mathjax: true
---

<div style="text-align: center;">
{% note success %} 
### 前言
{% endnote %}
</div>

上两节我们讲了二分查找算法。当时讲到，因为二分查找底层依赖的是数组随机访问的特性，所以只能用数组实现。如果数据存储在链表中，就真的没法用二分查找算法吗？

实际上，我们只要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做“跳表”，也就是今天的主要学习内容。

跳表这种数据结构对比来讲，可能会比较陌生，因为一般的数据结构和算法书籍都不会将。但是它确实是一种各方面性能都比较优秀的**动态数据结构**，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以代替**红黑树**。

Redis中的有序集合（Sorted Set）就是用跳表来实现的。如果你有一定基础，应该直到红黑树也可以实现快速的插入、删除和查找操作。**那redis为什么会选择用跳表来实现有序集合呢？**，为什么不用红黑树呢？学完今天的内容，你就知道答案了。


<div style="text-align: center;">
{% note success %} 
### 如何理解"跳表"
{% endnote %}
</div>

对于一个链表来说，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历列表。这样查找效率就会很低，时间复杂度很高，是O(n)。

{% asset_img 01.jpg %}

那怎样来提高查找效率呢？如果向下图那样，对链表建立一级索引，查找起来是不是就会快很多呢？每两个节点提取一个节点到上一级，我们把抽出来的那一级叫做索引或索引层。你可以看看我画的图，图中的down表示down指针，指向下一级节点。

{% asset_img 02.jpg %}

如果我们现在要查找某个节点，比如16。我们现在索引层遍历，当遍历到索引中值位13的节点时，我们发现下一个节点是17，那要查找的节点16肯定就在这两个节点之间。然后我们通过索引节点的down指针，下降到原始链表，继续遍历。这个时候我们只需要在遍历两个节点，就可以找到值为16的节点了。这样，原来要查找16，需要遍历10个节点，现在只需要遍历7个节点。

从这个例子，我们看出，**加了一层索引之后，查找一个节点需要遍历的节点个数减少了，也就是说查询效率提高了**。那如果我们再加一层索引呢？效率会不会提高更多？

跟前面建立一级索引的方式类似，我们每两个节点都抽出一个节点到二级索引。现在我们再来查找16，只需要遍历6个节点，需要遍历的节点数量又减少了。

{% asset_img 03.jpg %}

我举的例子数据量不大，所以即便加了两级索引，查找效率的提升也并不明显。我画了一个64个节点的链表，按照前面将的这种思路，建立了五级索引。

{% asset_img 04.jpg %}

从图中可以看出，原来没有索引的时候，查找62需要遍历62个节点，现在只需要遍历11个节点，速度是不是提高了很多？所以，当链表的长度n比较大时，比如，1000、10000的时候，在构建索引后，查找效率的提升就会非常明显。

前面讲的这种链表添加多级索引的结构，就是跳表。我通过例子给你展示了跳表是如何减少查询次数的，现在你应该比较清晰的知道，跳表确实可以提高查找效率的。接下来，我会定量的分析一下，用跳表查询到底有多快。

<div style="text-align: center;">
{% note success %} 
### 用跳表查询到底有多快
{% endnote %}
</div>

前面我讲过，算法的执行效率可以通过时间复杂度来衡量，这里依旧可以用。我们知道，在一个单链表中查询某个数据的时间复杂度为O(n)。那么在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？

这个时间复杂度的分析方法比较难想到，我把问题分析一下，先来看这样一个问题，如果链表里有n个节点，会有多少级索引呢？

按照我们刚才讲的，每两个节点会抽出一个节点作为上一级索引的节点，那第一级索引的个数大约为n/2个，第二级索引的节点个数大约为n/4，第三级节点个数大约为n/8，以此类推，也就是说，**第k级索引的节点个数是第k-1级索引的节点个数的1/2，那第k级索引的节点个数为$\frac{n}{2^k}$**。

假设索引有h级，最高级的索引有2个节点，通过上面的公式，我们可以得到$\frac{n}{2^k}$ = 2，从而求得$h=log_2(n-1)$。如果包含原始链表这一层，整个跳表的高度就是$log_2n$。我们在跳表中查询某个数据的时候，如果每一层都要遍历m个节点，那在跳表中查询一个数据的时间复杂度就是O($m*logn$)。

那么这个m的值是多少呢？按照前面这种结构，我们每一级索引都最多只需要遍历3个节点，也就是说m=3，为什么是3呢？我来解释一下。

假设我们要查找的数据是x，在第k级索引中，我们遍历到y节点之后，发现x大于y，小于后面的节点z，索引我们通过y的down指针，从第k级索引下降到第k-1级索引。在第k-1索引中，y和z之间只有3个节点（包含y和z），所以，我们在k-1级索引中最多只需要遍历3个节点，以此类推，每一级索引都最多只需要遍历3个节点。

通过上面的分析，我们得到m=3，所以在跳表中查询任意数据的时间复杂度就是O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找，是不是很神奇？不过天下没有免费的午餐，这种查询效率的提升，前提是建立了很多级索引，也就是我们前面讲过的空间换时间的思想。

<div style="text-align: center;">
{% note success %} 
### 跳表是不是很费内存
{% endnote %}
</div>

比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。那到底需要消耗多少额外的存储空间呢？





<br>
<br>
<br>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 信息流广告 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4127326375481893"
     data-ad-slot="9105526840"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>